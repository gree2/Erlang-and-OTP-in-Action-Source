<html>
<head><title>/Users/martinjlogan/book_workspace/code/chapter_11/_build/development/docs/coverage/gen_web_server/gws_server.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/martinjlogan/book_workspace/code/chapter_11/_build/development/apps/gen_web_server-0.1.0.2/ebin/../src/gws_server.erl by COVER 2010-04-13 at 16:47:42

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Martin Logan &lt;martinjlogan@Macintosh-2.local&gt;
        |  %%% @copyright (C) 2009, Martin Logan
        |  %%% @doc
        |  %%%  Handle a socket connection for incomming http packets. 
        |  %%% @end
        |  %%% Created : 10 Sep 2009 by Martin Logan &lt;martinjlogan@Macintosh-2.local&gt;
        |  %%%-------------------------------------------------------------------
        |  -module(gws_server).
        |  
        |  -behaviour(gen_server).
        |  
        |  %% API
        |  -export([start_link/3]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2,
        |  	 terminate/2, code_change/3]).
        |  
        |  -define(SERVER, ?MODULE). 
        |  
        |  -record(state, {lsock, socket, request_line = &lt;&lt;&gt;&gt;, headers = [], body = &lt;&lt;&gt;&gt;,
        |  		unparsed = &lt;&lt;&gt;&gt;, acc = [], content_length, callback, user_state, parent}).
        |  
        |  %%%===================================================================
        |  %%% API
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @doc
        |  %% Starts the server
        |  %%
        |  %% @spec start_link(Callback, LSock, UserArgs) -&gt; {ok, Pid} | ignore | {error, Error}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  start_link(Callback, LSock, UserArgs) -&gt;
<font color=red>     0..|      gen_server:start_link(?MODULE, [Callback, LSock, UserArgs, self()], []).</font>
        |  
        |  %%%===================================================================
        |  %%% gen_server callbacks
        |  %%%===================================================================
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Initiates the server
        |  %%
        |  %% @spec init(Args) -&gt; {ok, State} |
        |  %%                     {ok, State, Timeout} |
        |  %%                     ignore |
        |  %%                     {stop, Reason}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  init([Callback, LSock, UserArgs, Parent]) -&gt;
<font color=red>     0..|      error_logger:info_msg("in init calling to ~p~n", [Callback]),</font>
<font color=red>     0..|      {ok, UserState} = Callback:init(UserArgs),</font>
<font color=red>     0..|      {ok, #state{lsock = LSock, callback = Callback, user_state = UserState, parent = Parent}, 0}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling call messages
        |  %%
        |  %% @spec handle_call(Request, From, State) -&gt;
        |  %%                                   {reply, Reply, State} |
        |  %%                                   {reply, Reply, State, Timeout} |
        |  %%                                   {noreply, State} |
        |  %%                                   {noreply, State, Timeout} |
        |  %%                                   {stop, Reason, Reply, State} |
        |  %%                                   {stop, Reason, State}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  handle_call(_Request, _From, State) -&gt;
<font color=red>     0..|      Reply = ok,</font>
<font color=red>     0..|      {reply, Reply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling cast messages
        |  %%
        |  %% @spec handle_cast(Msg, State) -&gt; {noreply, State} |
        |  %%                                  {noreply, State, Timeout} |
        |  %%                                  {stop, Reason, State}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  handle_cast(_Request, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Handling all non call/cast messages
        |  %%
        |  %% @spec handle_info(Info, State) -&gt; {noreply, State} |
        |  %%                                   {noreply, State, Timeout} |
        |  %%                                   {stop, Reason, State}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  handle_info({tcp, _Socket, Packet}, #state{unparsed = Unparsed} = State) -&gt;
<font color=red>     0..|      handle_packet(State#state{unparsed = list_to_binary([Unparsed, Packet])});</font>
        |  handle_info({tcp_closed, _Socket}, State) -&gt;
<font color=red>     0..|      {stop, normal, State};</font>
        |  handle_info(timeout, #state{lsock = LSock, parent = Parent} = State) -&gt;
<font color=red>     0..|      {ok, Socket} = gen_tcp:accept(LSock),</font>
<font color=red>     0..|      gws_connection_sup:start_child(Parent),</font>
<font color=red>     0..|      inet:setopts(Socket,[{active,once}]),</font>
<font color=red>     0..|      {noreply, State#state{socket = Socket}}.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% This function is called by a gen_server when it is about to
        |  %% terminate. It should be the opposite of Module:init/1 and do any
        |  %% necessary cleaning up. When it returns, the gen_server terminates
        |  %% with Reason. The return value is ignored.
        |  %%
        |  %% @spec terminate(Reason, State) -&gt; void()
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  terminate(_Reason, _State) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  %%--------------------------------------------------------------------
        |  %% @private
        |  %% @doc
        |  %% Convert process state when code is changed
        |  %%
        |  %% @spec code_change(OldVsn, State, Extra) -&gt; {ok, NewState}
        |  %% @end
        |  %%--------------------------------------------------------------------
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%%===================================================================
        |  %%% Internal functions
        |  %%%===================================================================
        |  handle_packet(#state{request_line = &lt;&lt;&gt;&gt;, unparsed = Unparsed} = State) -&gt;
<font color=red>     0..|      case erlang:decode_packet(http, Unparsed, []) of</font>
        |  	{more, _} -&gt;
<font color=red>     0..|  	    inet:setopts(State#state.socket, [{active,once}]),</font>
<font color=red>     0..|  	    {noreply, State};</font>
        |  	{ok, RequestLine, Rest} -&gt;
<font color=red>     0..|  	    NewState = State#state{request_line = RequestLine, unparsed = Rest},</font>
<font color=red>     0..|  	    handle_packet(NewState);</font>
        |  	Error -&gt;
<font color=red>     0..|  	    throw({bad_initial_request_line, Error})</font>
        |      end;
        |  handle_packet(#state{headers = [], unparsed = Unparsed, acc = HeaderAcc} = State) -&gt;
<font color=red>     0..|      case decode_header(Unparsed, HeaderAcc) of</font>
        |  	{ok, NewHeaders, Rest} -&gt;
<font color=red>     0..|  	    ContentLength = list_to_integer(header_value_search('Content-Length', NewHeaders, "0")),</font>
<font color=red>     0..|  	    NewState = State#state{headers = NewHeaders, % put headers in recieved order</font>
        |  				   unparsed = Rest,
        |  				   content_length = ContentLength},
<font color=red>     0..|  	    case ContentLength of</font>
        |  		0 -&gt;
<font color=red>     0..|  		    reply(NewState);</font>
        |  		ContentLength -&gt;
<font color=red>     0..|  		    handle_continue(NewState),</font>
<font color=red>     0..|  		    handle_packet(NewState)</font>
        |  	    end;
        |  	{more, NewHeaderAcc, Unparsed} -&gt;
<font color=red>     0..|  	    NewState = State#state{acc = NewHeaderAcc, unparsed = Unparsed},</font>
<font color=red>     0..|  	    inet:setopts(State#state.socket, [{active,once}]),</font>
<font color=red>     0..|  	    {noreply, NewState}</font>
        |      end;
        |  handle_packet(#state{unparsed = Unparsed, content_length = ContentLength} = State) -&gt;
<font color=red>     0..|      case ContentLength - byte_size(Unparsed) of</font>
        |  	0 -&gt;
<font color=red>     0..|  	    reply(State#state{body = Unparsed});</font>
        |  	ContentLeftOver when ContentLeftOver &gt; 0 -&gt;
<font color=red>     0..|  	    inet:setopts(State#state.socket, [{active,once}]),</font>
<font color=red>     0..|  	    {noreply, State}</font>
        |      end.
        |      
        |  reply(State) -&gt; 
        |      #state{socket       = Socket,
        |  	   callback     = Callback,
        |  	   request_line = RequestLine,
        |  	   headers      = Headers,
        |  	   body         = Body,
<font color=red>     0..|  	   user_state   = UserState} = State,</font>
<font color=red>     0..|      Reply = handle_message(RequestLine, Headers, Body, Callback, UserState),</font>
<font color=red>     0..|      gen_tcp:send(Socket, Reply),</font>
<font color=red>     0..|      {stop, normal, State}.</font>
        |  
        |  handle_message({http_request, 'GET', _, _} = RequestLine, Headers, _Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:get(RequestLine, Headers, UserState);</font>
        |  handle_message({http_request, 'DELETE', _, _} = RequestLine, Headers, _Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:delete(RequestLine, Headers, UserState);</font>
        |  handle_message({http_request, 'HEAD', _, _} = RequestLine, Headers, _Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:head(RequestLine, Headers, UserState);</font>
        |  
        |  handle_message({http_request, 'POST', _, _} = RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:post(RequestLine, Headers, Body, UserState);</font>
        |  handle_message({http_request,'PUT',_,_} = RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:put(RequestLine, Headers, Body, UserState);</font>
        |  handle_message({http_request, 'TRACE', _, _} = RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:head(RequestLine, Headers, Body, UserState);</font>
        |  handle_message({http_request, 'CONNECT', _, _} = RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:head(RequestLine, Headers, Body, UserState);</font>
        |  handle_message({http_request, 'OPTIONS', _, _} = RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:options(RequestLine, Headers, Body, UserState);</font>
        |  handle_message(RequestLine, Headers, Body, CallBack, UserState) -&gt;
<font color=red>     0..|      CallBack:other_methods(RequestLine, Headers, Body, UserState).</font>
        |  
        |  
        |  decode_header(Unparsed, Acc) -&gt;
<font color=red>     0..|      case erlang:decode_packet(httph, Unparsed, []) of</font>
        |  	{ok, http_eoh, Rest} -&gt;
<font color=red>     0..|  	    {ok, lists:reverse(Acc), Rest};</font>
        |  	{more, _} -&gt;
<font color=red>     0..|  	    {more, Acc, Unparsed};</font>
        |  	{ok, {_, _, Name, _, Value}, Rest} -&gt;
<font color=red>     0..|  	    decode_header(Rest, [{Name, Value}|Acc]);</font>
        |  	{error, Reason} -&gt;
<font color=red>     0..|  	    throw({bad_header, Reason})</font>
        |      end.
        |  
        |  header_value_search(Key, List, Default) -&gt;
<font color=red>     0..|      case lists:keysearch(Key, 1, List) of</font>
<font color=red>     0..|  	{value, {Key, Value}} -&gt; Value;</font>
<font color=red>     0..|  	false                 -&gt; Default</font>
        |      end.
        |  
        |  %% @private
        |  %% @doc send a 100 continue packet if the client expects it
        |  %% @end
        |  handle_continue(#state{socket = Socket, headers = Headers}) -&gt;
<font color=red>     0..|      case lists:keymember("100-continue", 2, Headers) of</font>
<font color=red>     0..|  	true  -&gt; gen_tcp:send(Socket, gen_web_server:http_reply(100));</font>
<font color=red>     0..|  	false -&gt; ok</font>
        |      end.
        |  
</pre>
</body>
</html>
